import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ViewChild, ChangeDetectionStrategy } from '@angular/core';
import { YAxisTicksComponent } from './y-axis-ticks.component';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './y-axis-ticks.component';
import * as ɵngcc3 from './axis-label.component';

const _c0 = ["ngx-charts-y-axis", ""];
function YAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function YAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickValues", ctx_r0.ticks)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.yScale)("orient", ctx_r0.yOrient)("showGridLines", ctx_r0.showGridLines)("gridLineWidth", ctx_r0.dims.width)("referenceLines", ctx_r0.referenceLines)("showRefLines", ctx_r0.showRefLines)("showRefLabels", ctx_r0.showRefLabels)("height", ctx_r0.dims.height);
} }
function YAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.yOrient)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
let YAxisComponent = class YAxisComponent {
    constructor() {
        this.showGridLines = false;
        this.yOrient = 'left';
        this.yAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.yAxisClassName = 'y axis';
        this.labelOffset = 15;
        this.fill = 'none';
        this.stroke = '#CCC';
        this.tickStroke = '#CCC';
        this.strokeWidth = 1;
        this.padding = 5;
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        this.offset = -(this.yAxisOffset + this.padding);
        if (this.yOrient === 'right') {
            this.labelOffset = 65;
            this.transform = `translate(${this.offset + this.dims.width} , 0)`;
        }
        else {
            this.offset = this.offset;
            this.transform = `translate(${this.offset} , 0)`;
        }
        if (this.yAxisTickCount !== undefined) {
            this.tickArguments = [this.yAxisTickCount];
        }
    }
    emitTicksWidth({ width }) {
        if (width !== this.labelOffset && this.yOrient === 'right') {
            this.labelOffset = width + this.labelOffset;
            setTimeout(() => {
                this.dimensionsChanged.emit({ width });
            }, 0);
        }
        else if (width !== this.labelOffset) {
            this.labelOffset = width;
            setTimeout(() => {
                this.dimensionsChanged.emit({ width });
            }, 0);
        }
    }
};
YAxisComponent.ɵfac = function YAxisComponent_Factory(t) { return new (t || YAxisComponent)(); };
YAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisComponent, selectors: [["g", "ngx-charts-y-axis", ""]], viewQuery: function YAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(YAxisTicksComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { showGridLines: "showGridLines", yOrient: "yOrient", yAxisOffset: "yAxisOffset", yScale: "yScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", ticks: "ticks", showLabel: "showLabel", labelText: "labelText", yAxisTickInterval: "yAxisTickInterval", yAxisTickCount: "yAxisTickCount", referenceLines: "referenceLines", showRefLines: "showRefLines", showRefLabels: "showRefLabels" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 3, vars: 4, consts: [["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function YAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, YAxisComponent__svg_g_1_Template, 1, 14, "g", 0);
        ɵngcc0.ɵɵtemplate(2, YAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.yAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.YAxisTicksComponent, ɵngcc3.AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], YAxisComponent.prototype, "yScale", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "dims", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "trimTicks", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "maxTickLength", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "tickFormatting", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "ticks", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "showGridLines", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "showLabel", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "labelText", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "yAxisTickInterval", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "yAxisTickCount", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "yOrient", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "referenceLines", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "showRefLines", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "showRefLabels", void 0);
__decorate([
    Input()
], YAxisComponent.prototype, "yAxisOffset", void 0);
__decorate([
    Output()
], YAxisComponent.prototype, "dimensionsChanged", void 0);
__decorate([
    ViewChild(YAxisTicksComponent)
], YAxisComponent.prototype, "ticksComponent", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-y-axis]',
                template: `
    <svg:g [attr.class]="yAxisClassName" [attr.transform]="transform">
      <svg:g
        ngx-charts-y-axis-ticks
        *ngIf="yScale"
        [trimTicks]="trimTicks"
        [maxTickLength]="maxTickLength"
        [tickFormatting]="tickFormatting"
        [tickArguments]="tickArguments"
        [tickValues]="ticks"
        [tickStroke]="tickStroke"
        [scale]="yScale"
        [orient]="yOrient"
        [showGridLines]="showGridLines"
        [gridLineWidth]="dims.width"
        [referenceLines]="referenceLines"
        [showRefLines]="showRefLines"
        [showRefLabels]="showRefLabels"
        [height]="dims.height"
        (dimensionsChanged)="emitTicksWidth($event)"
      />

      <svg:g
        ngx-charts-axis-label
        *ngIf="showLabel"
        [label]="labelText"
        [offset]="labelOffset"
        [orient]="yOrient"
        [height]="dims.height"
        [width]="dims.width"
      ></svg:g>
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { showGridLines: [{
            type: Input
        }], yOrient: [{
            type: Input
        }], yAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], yScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], ticks: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], yAxisTickInterval: [{
            type: Input
        }], yAxisTickCount: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [YAxisTicksComponent]
        }] }); })();
export { YAxisComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieS1heGlzLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiQHN3aW1sYW5lL25neC1jaGFydHMvbGliL2NvbW1vbi9heGVzL3ktYXhpcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBRVosU0FBUyxFQUVULHVCQUF1QixFQUN4QixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUMvRCxJQUFhLGNBQWMsR0FBM0IsTUFBYSxjQUFjO0FBQUcsSUFBOUI7QUFBZ0IsUUFPTCxrQkFBYSxHQUFHLEtBQUssQ0FBQztBQUNqQyxRQUlXLFlBQU8sR0FBVyxNQUFNLENBQUM7QUFDcEMsUUFHVyxnQkFBVyxHQUFXLENBQUMsQ0FBQztBQUNuQyxRQUFZLHNCQUFpQixHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7QUFDbkQsUUFDRSxtQkFBYyxHQUFXLFFBQVEsQ0FBQztBQUNwQyxRQUdFLGdCQUFXLEdBQVcsRUFBRSxDQUFDO0FBQzNCLFFBQUUsU0FBSSxHQUFXLE1BQU0sQ0FBQztBQUN4QixRQUFFLFdBQU0sR0FBVyxNQUFNLENBQUM7QUFDMUIsUUFBRSxlQUFVLEdBQVcsTUFBTSxDQUFDO0FBQzlCLFFBQUUsZ0JBQVcsR0FBVyxDQUFDLENBQUM7QUFDMUIsUUFBRSxZQUFPLEdBQVcsQ0FBQyxDQUFDO0FBQ3RCLElBbUNBLENBQUM7QUFDRCxJQWpDRSxXQUFXLENBQUMsT0FBc0I7QUFBSSxRQUNwQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDbEIsSUFBRSxDQUFDO0FBQ0gsSUFDRSxNQUFNO0FBQUssUUFDVCxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNy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USxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQ1QsVUFDRDtDQUFlLEVBQUUsdUJBQXVCLENBQUM7SUFBTSxNQUNoRCxDQUFDLElBQ1c7O0FBQWMsQ0FnRTFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsU0FqRVksY0FBYztBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIE9uQ2hhbmdlcyxcbiAgVmlld0NoaWxkLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFlBeGlzVGlja3NDb21wb25lbnQgfSBmcm9tICcuL3ktYXhpcy10aWNrcy5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteS1heGlzXScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpnIFthdHRyLmNsYXNzXT1cInlBeGlzQ2xhc3NOYW1lXCIgW2F0dHIudHJhbnNmb3JtXT1cInRyYW5zZm9ybVwiPlxuICAgICAgPHN2ZzpnXG4gICAgICAgIG5neC1jaGFydHMteS1heGlzLXRpY2tzXG4gICAgICAgICpuZ0lmPVwieVNjYWxlXCJcbiAgICAgICAgW3RyaW1UaWNrc109XCJ0cmltVGlja3NcIlxuICAgICAgICBbbWF4VGlja0xlbmd0aF09XCJtYXhUaWNrTGVuZ3RoXCJcbiAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cInRpY2tGb3JtYXR0aW5nXCJcbiAgICAgICAgW3RpY2tBcmd1bWVudHNdPVwidGlja0FyZ3VtZW50c1wiXG4gICAgICAgIFt0aWNrVmFsdWVzXT1cInRpY2tzXCJcbiAgICAgICAgW3RpY2tTdHJva2VdPVwidGlja1N0cm9rZVwiXG4gICAgICAgIFtzY2FsZV09XCJ5U2NhbGVcIlxuICAgICAgICBbb3JpZW50XT1cInlPcmllbnRcIlxuICAgICAgICBbc2hvd0dyaWRMaW5lc109XCJzaG93R3JpZExpbmVzXCJcbiAgICAgICAgW2dyaWRMaW5lV2lkdGhdPVwiZGltcy53aWR0aFwiXG4gICAgICAgIFtyZWZlcmVuY2VMaW5lc109XCJyZWZlcmVuY2VMaW5lc1wiXG4gICAgICAgIFtzaG93UmVmTGluZXNdPVwic2hvd1JlZkxpbmVzXCJcbiAgICAgICAgW3Nob3dSZWZMYWJlbHNdPVwic2hvd1JlZkxhYmVsc1wiXG4gICAgICAgIFtoZWlnaHRdPVwiZGltcy5oZWlnaHRcIlxuICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVwiZW1pdFRpY2tzV2lkdGgoJGV2ZW50KVwiXG4gICAgICAvPlxuXG4gICAgICA8c3ZnOmdcbiAgICAgICAgbmd4LWNoYXJ0cy1heGlzLWxhYmVsXG4gICAgICAgICpuZ0lmPVwic2hvd0xhYmVsXCJcbiAgICAgICAgW2xhYmVsXT1cImxhYmVsVGV4dFwiXG4gICAgICAgIFtvZmZzZXRdPVwibGFiZWxPZmZzZXRcIlxuICAgICAgICBbb3JpZW50XT1cInlPcmllbnRcIlxuICAgICAgICBbaGVpZ2h0XT1cImRpbXMuaGVpZ2h0XCJcbiAgICAgICAgW3dpZHRoXT1cImRpbXMud2lkdGhcIlxuICAgICAgPjwvc3ZnOmc+XG4gICAgPC9zdmc6Zz5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgWUF4aXNDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSB5U2NhbGU7XG4gIEBJbnB1dCgpIGRpbXM7XG4gIEBJbnB1dCgpIHRyaW1UaWNrczogYm9vbGVhbjtcbiAgQElucHV0KCkgbWF4VGlja0xlbmd0aDogbnVtYmVyO1xuICBASW5wdXQoKSB0aWNrRm9ybWF0dGluZztcbiAgQElucHV0KCkgdGlja3M6IGFueVtdO1xuICBASW5wdXQoKSBzaG93R3JpZExpbmVzID0gZmFsc2U7XG4gIEBJbnB1dCgpIHNob3dMYWJlbDtcbiAgQElucHV0KCkgbGFiZWxUZXh0O1xuICBASW5wdXQoKSB5QXhpc1RpY2tJbnRlcnZhbDtcbiAgQElucHV0KCkgeUF4aXNUaWNrQ291bnQ6IGFueTtcbiAgQElucHV0KCkgeU9yaWVudDogc3RyaW5nID0gJ2xlZnQnO1xuICBASW5wdXQoKSByZWZlcmVuY2VMaW5lcztcbiAgQElucHV0KCkgc2hvd1JlZkxpbmVzO1xuICBASW5wdXQoKSBzaG93UmVmTGFiZWxzO1xuICBASW5wdXQoKSB5QXhpc09mZnNldDogbnVtYmVyID0gMDtcbiAgQE91dHB1dCgpIGRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHlBeGlzQ2xhc3NOYW1lOiBzdHJpbmcgPSAneSBheGlzJztcbiAgdGlja0FyZ3VtZW50czogYW55O1xuICBvZmZzZXQ6IGFueTtcbiAgdHJhbnNmb3JtOiBhbnk7XG4gIGxhYmVsT2Zmc2V0OiBudW1iZXIgPSAxNTtcbiAgZmlsbDogc3RyaW5nID0gJ25vbmUnO1xuICBzdHJva2U6IHN0cmluZyA9ICcjQ0NDJztcbiAgdGlja1N0cm9rZTogc3RyaW5nID0gJyNDQ0MnO1xuICBzdHJva2VXaWR0aDogbnVtYmVyID0gMTtcbiAgcGFkZGluZzogbnVtYmVyID0gNTtcblxuICBAVmlld0NoaWxkKFlBeGlzVGlja3NDb21wb25lbnQpIHRpY2tzQ29tcG9uZW50OiBZQXhpc1RpY2tzQ29tcG9uZW50O1xuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdXBkYXRlKCk6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0ID0gLSh0aGlzLnlBeGlzT2Zmc2V0ICsgdGhpcy5wYWRkaW5nKTtcbiAgICBpZiAodGhpcy55T3JpZW50ID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gNjU7XG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt0aGlzLm9mZnNldCArIHRoaXMuZGltcy53aWR0aH0gLCAwKWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt0aGlzLm9mZnNldH0gLCAwKWA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMueUF4aXNUaWNrQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50aWNrQXJndW1lbnRzID0gW3RoaXMueUF4aXNUaWNrQ291bnRdO1xuICAgIH1cbiAgfVxuXG4gIGVtaXRUaWNrc1dpZHRoKHsgd2lkdGggfSk6IHZvaWQge1xuICAgIGlmICh3aWR0aCAhPT0gdGhpcy5sYWJlbE9mZnNldCAmJiB0aGlzLnlPcmllbnQgPT09ICdyaWdodCcpIHtcbiAgICAgIHRoaXMubGFiZWxPZmZzZXQgPSB3aWR0aCArIHRoaXMubGFiZWxPZmZzZXQ7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgd2lkdGggfSk7XG4gICAgICB9LCAwKTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSB0aGlzLmxhYmVsT2Zmc2V0KSB7XG4gICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gd2lkdGg7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgd2lkdGggfSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==