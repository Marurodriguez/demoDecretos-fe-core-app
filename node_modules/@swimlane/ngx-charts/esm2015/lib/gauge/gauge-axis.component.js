import { __decorate } from "tslib";
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import { line } from 'd3-shape';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r3.line);
} }
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelementStart(1, "text", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r4 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("text-anchor", tick_r4.textAnchor);
    ɵngcc0.ɵɵattribute("transform", tick_r4.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tick_r4.text, " ");
} }
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r5 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r5.line);
} }
let GaugeAxisComponent = class GaugeAxisComponent {
    constructor() {
        this.rotate = '';
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        this.rotationAngle = -90 + this.startAngle;
        this.rotate = `rotate(${this.rotationAngle})`;
        this.ticks = this.getTicks();
    }
    getTicks() {
        const bigTickSegment = this.angleSpan / this.bigSegments;
        const smallTickSegment = bigTickSegment / this.smallSegments;
        const tickLength = 20;
        const ticks = {
            big: [],
            small: []
        };
        const startDistance = this.radius + 10;
        const textDist = startDistance + tickLength + 10;
        for (let i = 0; i <= this.bigSegments; i++) {
            const angleDeg = i * bigTickSegment;
            const angle = (angleDeg * Math.PI) / 180;
            const textAnchor = this.getTextAnchor(angleDeg);
            let skip = false;
            if (i === 0 && this.angleSpan === 360) {
                skip = true;
            }
            if (!skip) {
                let text = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
                if (this.tickFormatting) {
                    text = this.tickFormatting(text);
                }
                ticks.big.push({
                    line: this.getTickPath(startDistance, tickLength, angle),
                    textAnchor,
                    text,
                    textTransform: `
            translate(${textDist * Math.cos(angle)}, ${textDist * Math.sin(angle)}) rotate(${-this.rotationAngle})
          `
                });
            }
            if (i === this.bigSegments) {
                continue;
            }
            for (let j = 1; j <= this.smallSegments; j++) {
                const smallAngleDeg = angleDeg + j * smallTickSegment;
                const smallAngle = (smallAngleDeg * Math.PI) / 180;
                ticks.small.push({
                    line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
                });
            }
        }
        return ticks;
    }
    getTextAnchor(angle) {
        // [0, 45] = 'middle';
        // [46, 135] = 'start';
        // [136, 225] = 'middle';
        // [226, 315] = 'end';
        angle = (this.startAngle + angle) % 360;
        let textAnchor = 'middle';
        if (angle > 45 && angle <= 135) {
            textAnchor = 'start';
        }
        else if (angle > 225 && angle <= 315) {
            textAnchor = 'end';
        }
        return textAnchor;
    }
    getTickPath(startDistance, tickLength, angle) {
        const y1 = startDistance * Math.sin(angle);
        const y2 = (startDistance + tickLength) * Math.sin(angle);
        const x1 = startDistance * Math.cos(angle);
        const x2 = (startDistance + tickLength) * Math.cos(angle);
        const points = [
            { x: x1, y: y1 },
            { x: x2, y: y2 }
        ];
        const lineGenerator = line()
            .x(d => d.x)
            .y(d => d.y);
        return lineGenerator(points);
    }
};
GaugeAxisComponent.ɵfac = function GaugeAxisComponent_Factory(t) { return new (t || GaugeAxisComponent)(); };
GaugeAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeAxisComponent, selectors: [["g", "ngx-charts-gauge-axis", ""]], inputs: { bigSegments: "bigSegments", smallSegments: "smallSegments", min: "min", max: "max", angleSpan: "angleSpan", startAngle: "startAngle", radius: "radius", valueScale: "valueScale", tickFormatting: "tickFormatting" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 4, vars: 4, consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]], template: function GaugeAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0);
        ɵngcc0.ɵɵtemplate(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0);
        ɵngcc0.ɵɵtemplate(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.rotate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.small);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], GaugeAxisComponent.prototype, "bigSegments", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "smallSegments", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "min", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "max", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "angleSpan", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "startAngle", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "radius", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "valueScale", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "tickFormatting", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-axis]',
                template: `
    <svg:g [attr.transform]="rotate">
      <svg:g *ngFor="let tick of ticks.big" class="gauge-tick gauge-tick-large">
        <svg:path [attr.d]="tick.line" />
      </svg:g>
      <svg:g *ngFor="let tick of ticks.big" class="gauge-tick gauge-tick-large">
        <svg:text
          [style.textAnchor]="tick.textAnchor"
          [attr.transform]="tick.textTransform"
          alignment-baseline="central"
        >
          {{ tick.text }}
        </svg:text>
      </svg:g>
      <svg:g *ngFor="let tick of ticks.small" class="gauge-tick gauge-tick-small">
        <svg:path [attr.d]="tick.line" />
      </svg:g>
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], radius: [{
            type: Input
        }], valueScale: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }] }); })();
export { GaugeAxisComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F1Z2UtYXhpcy5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIkBzd2ltbGFuZS9uZ3gtY2hhcnRzL2xpYi9nYXVnZS9nYXVnZS1heGlzLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQTRCLHVCQUF1QixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3BHLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QmhDLElBQWEsa0JBQWtCLEdBQS9CLE1BQWEsa0JBQWtCO0FBQUcsSUFBbEM7QUFBZ0IsUUFhZCxXQUFNLEdBQVcsRUFBRSxDQUFDO0FBQ3RCLElBaUdBLENBQUM7QUFDRCxJQWpHRSxXQUFXLENBQUMsT0FBc0I7QUFDcEMsUUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDbEIsSUFBRSxDQUFDO0FBQ0gsSUFDRSxNQUFNO0FBQUssUUFDVCxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7QUFDL0MsUUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLFVBQVUsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDO0FBQ2xELFFBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDakMsSUFBRSxDQUFDO0FBQ0gsSUFDRSxRQUFRO0FBQUssUUFDWCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7QUFDN0QsUUFBSSxNQUFNLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO0FBQ2pFLFFBQUksTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQzFCLFFBQUksTUFBTSxLQUFLLEdBQUc7QUFDbEIsWUFBTSxHQUFHLEVBQUUsRUFBRTtBQUNi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QyxDQUFDLENBQUMsQ0FBQztBQUNsQixhQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuQixRQUFJLE9BQU8sYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2pDLElBQUUsQ0FBQztBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OytFQUFBO0FBOUdVO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsdURBQWlCO0FBQ2pCO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMseURBQW1CO0FBQ25CO0FBQ1IsSUFEQSxLQUFLLEVBQUU7QUFBQywrQ0FBUztBQUNUO0FBQ1IsSUFEQSxLQUFLLEVBQUU7QUFBQywrQ0FBUztBQUNUO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMscURBQWtCO0FBQ2xCO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsc0RBQW1CO0FBQ25CO0FBQ1gsSUFERyxLQUFLLEVBQUU7QUFBQyxrREFBWTtBQUNaO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsc0RBQWdCO0FBQ2hCO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsMERBQW9CO0FBVGxCLGtCQUFrQixvQkF2QjlCLFNBQVMsQ0FBQyxVQUNULFFBQVEsRUFBRTtpQkFBMEI7RUFDcEMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7O3VFQWtCVCxVQUNEO2FBQWUsRUFBRSx1QkFBdUIsQ0FBQztHQUFNLE1BQ2hELENBQUMsSUFDVzs7SUFBa0I7QUErRzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFDRDtBQUFDLFNBaEhZLGtCQUFrQjtBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbGluZSB9IGZyb20gJ2QzLXNoYXBlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWdhdWdlLWF4aXNdJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cInJvdGF0ZVwiPlxuICAgICAgPHN2ZzpnICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRpY2tzLmJpZ1wiIGNsYXNzPVwiZ2F1Z2UtdGljayBnYXVnZS10aWNrLWxhcmdlXCI+XG4gICAgICAgIDxzdmc6cGF0aCBbYXR0ci5kXT1cInRpY2subGluZVwiIC8+XG4gICAgICA8L3N2ZzpnPlxuICAgICAgPHN2ZzpnICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRpY2tzLmJpZ1wiIGNsYXNzPVwiZ2F1Z2UtdGljayBnYXVnZS10aWNrLWxhcmdlXCI+XG4gICAgICAgIDxzdmc6dGV4dFxuICAgICAgICAgIFtzdHlsZS50ZXh0QW5jaG9yXT1cInRpY2sudGV4dEFuY2hvclwiXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cInRpY2sudGV4dFRyYW5zZm9ybVwiXG4gICAgICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVwiY2VudHJhbFwiXG4gICAgICAgID5cbiAgICAgICAgICB7eyB0aWNrLnRleHQgfX1cbiAgICAgICAgPC9zdmc6dGV4dD5cbiAgICAgIDwvc3ZnOmc+XG4gICAgICA8c3ZnOmcgKm5nRm9yPVwibGV0IHRpY2sgb2YgdGlja3Muc21hbGxcIiBjbGFzcz1cImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1zbWFsbFwiPlxuICAgICAgICA8c3ZnOnBhdGggW2F0dHIuZF09XCJ0aWNrLmxpbmVcIiAvPlxuICAgICAgPC9zdmc6Zz5cbiAgICA8L3N2ZzpnPlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBHYXVnZUF4aXNDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBiaWdTZWdtZW50czogYW55O1xuICBASW5wdXQoKSBzbWFsbFNlZ21lbnRzOiBhbnk7XG4gIEBJbnB1dCgpIG1pbjogYW55O1xuICBASW5wdXQoKSBtYXg6IGFueTtcbiAgQElucHV0KCkgYW5nbGVTcGFuOiBudW1iZXI7XG4gIEBJbnB1dCgpIHN0YXJ0QW5nbGU6IG51bWJlcjtcbiAgQElucHV0KCkgcmFkaXVzOiBhbnk7XG4gIEBJbnB1dCgpIHZhbHVlU2NhbGU6IGFueTtcbiAgQElucHV0KCkgdGlja0Zvcm1hdHRpbmc6IGFueTtcblxuICB0aWNrczogYW55O1xuICByb3RhdGlvbkFuZ2xlOiBudW1iZXI7XG4gIHJvdGF0ZTogc3RyaW5nID0gJyc7XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB1cGRhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5yb3RhdGlvbkFuZ2xlID0gLTkwICsgdGhpcy5zdGFydEFuZ2xlO1xuICAgIHRoaXMucm90YXRlID0gYHJvdGF0ZSgke3RoaXMucm90YXRpb25BbmdsZX0pYDtcbiAgICB0aGlzLnRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuICB9XG5cbiAgZ2V0VGlja3MoKTogYW55IHtcbiAgICBjb25zdCBiaWdUaWNrU2VnbWVudCA9IHRoaXMuYW5nbGVTcGFuIC8gdGhpcy5iaWdTZWdtZW50cztcbiAgICBjb25zdCBzbWFsbFRpY2tTZWdtZW50ID0gYmlnVGlja1NlZ21lbnQgLyB0aGlzLnNtYWxsU2VnbWVudHM7XG4gICAgY29uc3QgdGlja0xlbmd0aCA9IDIwO1xuICAgIGNvbnN0IHRpY2tzID0ge1xuICAgICAgYmlnOiBbXSxcbiAgICAgIHNtYWxsOiBbXVxuICAgIH07XG5cbiAgICBjb25zdCBzdGFydERpc3RhbmNlID0gdGhpcy5yYWRpdXMgKyAxMDtcbiAgICBjb25zdCB0ZXh0RGlzdCA9IHN0YXJ0RGlzdGFuY2UgKyB0aWNrTGVuZ3RoICsgMTA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLmJpZ1NlZ21lbnRzOyBpKyspIHtcbiAgICAgIGNvbnN0IGFuZ2xlRGVnID0gaSAqIGJpZ1RpY2tTZWdtZW50O1xuICAgICAgY29uc3QgYW5nbGUgPSAoYW5nbGVEZWcgKiBNYXRoLlBJKSAvIDE4MDtcblxuICAgICAgY29uc3QgdGV4dEFuY2hvciA9IHRoaXMuZ2V0VGV4dEFuY2hvcihhbmdsZURlZyk7XG5cbiAgICAgIGxldCBza2lwID0gZmFsc2U7XG4gICAgICBpZiAoaSA9PT0gMCAmJiB0aGlzLmFuZ2xlU3BhbiA9PT0gMzYwKSB7XG4gICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgbGV0IHRleHQgPSBOdW1iZXIucGFyc2VGbG9hdCh0aGlzLnZhbHVlU2NhbGUuaW52ZXJ0KGFuZ2xlRGVnKS50b1N0cmluZygpKS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICBpZiAodGhpcy50aWNrRm9ybWF0dGluZykge1xuICAgICAgICAgIHRleHQgPSB0aGlzLnRpY2tGb3JtYXR0aW5nKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tzLmJpZy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiB0aGlzLmdldFRpY2tQYXRoKHN0YXJ0RGlzdGFuY2UsIHRpY2tMZW5ndGgsIGFuZ2xlKSxcbiAgICAgICAgICB0ZXh0QW5jaG9yLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgdGV4dFRyYW5zZm9ybTogYFxuICAgICAgICAgICAgdHJhbnNsYXRlKCR7dGV4dERpc3QgKiBNYXRoLmNvcyhhbmdsZSl9LCAke3RleHREaXN0ICogTWF0aC5zaW4oYW5nbGUpfSkgcm90YXRlKCR7LXRoaXMucm90YXRpb25BbmdsZX0pXG4gICAgICAgICAgYFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IHRoaXMuYmlnU2VnbWVudHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IHRoaXMuc21hbGxTZWdtZW50czsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNtYWxsQW5nbGVEZWcgPSBhbmdsZURlZyArIGogKiBzbWFsbFRpY2tTZWdtZW50O1xuICAgICAgICBjb25zdCBzbWFsbEFuZ2xlID0gKHNtYWxsQW5nbGVEZWcgKiBNYXRoLlBJKSAvIDE4MDtcblxuICAgICAgICB0aWNrcy5zbWFsbC5wdXNoKHtcbiAgICAgICAgICBsaW5lOiB0aGlzLmdldFRpY2tQYXRoKHN0YXJ0RGlzdGFuY2UsIHRpY2tMZW5ndGggLyAyLCBzbWFsbEFuZ2xlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICBnZXRUZXh0QW5jaG9yKGFuZ2xlKSB7XG4gICAgLy8gWzAsIDQ1XSA9ICdtaWRkbGUnO1xuICAgIC8vIFs0NiwgMTM1XSA9ICdzdGFydCc7XG4gICAgLy8gWzEzNiwgMjI1XSA9ICdtaWRkbGUnO1xuICAgIC8vIFsyMjYsIDMxNV0gPSAnZW5kJztcblxuICAgIGFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIGFuZ2xlKSAlIDM2MDtcbiAgICBsZXQgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgIGlmIChhbmdsZSA+IDQ1ICYmIGFuZ2xlIDw9IDEzNSkge1xuICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgfSBlbHNlIGlmIChhbmdsZSA+IDIyNSAmJiBhbmdsZSA8PSAzMTUpIHtcbiAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICB9XG4gICAgcmV0dXJuIHRleHRBbmNob3I7XG4gIH1cblxuICBnZXRUaWNrUGF0aChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoLCBhbmdsZSk6IGFueSB7XG4gICAgY29uc3QgeTEgPSBzdGFydERpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHkyID0gKHN0YXJ0RGlzdGFuY2UgKyB0aWNrTGVuZ3RoKSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB4MSA9IHN0YXJ0RGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3QgeDIgPSAoc3RhcnREaXN0YW5jZSArIHRpY2tMZW5ndGgpICogTWF0aC5jb3MoYW5nbGUpO1xuXG4gICAgY29uc3QgcG9pbnRzID0gW1xuICAgICAgeyB4OiB4MSwgeTogeTEgfSxcbiAgICAgIHsgeDogeDIsIHk6IHkyIH1cbiAgICBdO1xuICAgIGNvbnN0IGxpbmVHZW5lcmF0b3IgPSBsaW5lPGFueT4oKVxuICAgICAgLngoZCA9PiBkLngpXG4gICAgICAueShkID0+IGQueSk7XG4gICAgcmV0dXJuIGxpbmVHZW5lcmF0b3IocG9pbnRzKTtcbiAgfVxufVxuIl19