{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} value\n * @return {?}\n */\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/** @type {?} */\n\n\nvar untilDestroyed = function untilDestroyed(componentInstance) {\n  var destroyMethodName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ngOnDestroy';\n  return function (source) {\n    /** @type {?} */\n    var originalDestroy = componentInstance[destroyMethodName];\n\n    if (isFunction(originalDestroy) === false) {\n      throw new Error(\"\".concat(componentInstance.constructor.name, \" is using untilDestroyed but doesn't implement \").concat(destroyMethodName));\n    }\n\n    if (!componentInstance['__takeUntilDestroy']) {\n      componentInstance['__takeUntilDestroy'] = new Subject();\n\n      componentInstance[destroyMethodName] = function () {\n        isFunction(originalDestroy) && originalDestroy.apply(this, arguments);\n        componentInstance['__takeUntilDestroy'].next(true);\n        componentInstance['__takeUntilDestroy'].complete();\n      };\n    }\n\n    return source.pipe(takeUntil(componentInstance['__takeUntilDestroy']));\n  };\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { untilDestroyed };","map":{"version":3,"sources":["ng://ngx-take-until-destroy/src/take-until-destroy.ts"],"names":[],"mappings":";;;;;;;AAAA;;;;;AAGA,SAAA,UAAA,CAAoB,KAApB,EAAyB;AACvB,SAAO,OAAO,KAAP,KAAiB,UAAxB;AACD;;;;AAED,IAAa,cAAc,GAAG,SAAjB,cAAiB,CAC5B,iBAD4B;AAAA,MAE5B,iBAF4B,uEAER,aAFQ;AAAA,SAGzB,UAAI,MAAJ,EAAyB;;AAC5B,QAAM,eAAe,GAAG,iBAAiB,CAAC,iBAAD,CAAzC;;AACA,QAAI,UAAU,CAAC,eAAD,CAAV,KAAgC,KAApC,EAA2C;AACzC,YAAM,IAAI,KAAJ,WAEF,iBAAiB,CAAC,WAAlB,CAA8B,IAF5B,4DAG8C,iBAH9C,EAAN;AAKD;;AACD,QAAI,CAAC,iBAAiB,CAAC,oBAAD,CAAtB,EAA8C;AAC5C,MAAA,iBAAiB,CAAC,oBAAD,CAAjB,GAA0C,IAAI,OAAJ,EAA1C;;AAEA,MAAA,iBAAiB,CAAC,iBAAD,CAAjB,GAAuC,YAAA;AACrC,QAAA,UAAU,CAAC,eAAD,CAAV,IAA+B,eAAe,CAAC,KAAhB,CAAsB,IAAtB,EAA4B,SAA5B,CAA/B;AACA,QAAA,iBAAiB,CAAC,oBAAD,CAAjB,CAAwC,IAAxC,CAA6C,IAA7C;AACA,QAAA,iBAAiB,CAAC,oBAAD,CAAjB,CAAwC,QAAxC;AACD,OAJD;AAKD;;AACD,WAAO,MAAM,CAAC,IAAP,CAAY,SAAS,CAAI,iBAAiB,CAAC,oBAAD,CAArB,CAArB,CAAP;AACD,GAtB6B;AAAA,CAA9B","sourcesContent":["import { Observable, Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nexport const untilDestroyed = (\n  componentInstance,\n  destroyMethodName = 'ngOnDestroy'\n) => <T>(source: Observable<T>) => {\n  const originalDestroy = componentInstance[destroyMethodName];\n  if (isFunction(originalDestroy) === false) {\n    throw new Error(\n      `${\n        componentInstance.constructor.name\n      } is using untilDestroyed but doesn't implement ${destroyMethodName}`\n    );\n  }\n  if (!componentInstance['__takeUntilDestroy']) {\n    componentInstance['__takeUntilDestroy'] = new Subject();\n\n    componentInstance[destroyMethodName] = function() {\n      isFunction(originalDestroy) && originalDestroy.apply(this, arguments);\n      componentInstance['__takeUntilDestroy'].next(true);\n      componentInstance['__takeUntilDestroy'].complete();\n    };\n  }\n  return source.pipe(takeUntil<T>(componentInstance['__takeUntilDestroy']));\n};\n"]},"metadata":{},"sourceType":"module"}