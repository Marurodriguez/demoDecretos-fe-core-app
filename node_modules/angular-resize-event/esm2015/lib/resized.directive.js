import { Directive, ElementRef, EventEmitter, Output } from '@angular/core';
import { ResizeSensor } from 'css-element-queries';
import { ResizedEvent } from './resized-event';
import * as ɵngcc0 from '@angular/core';
export class ResizedDirective {
    constructor(element) {
        this.element = element;
        this.resized = new EventEmitter();
    }
    ngOnInit() {
        // only initialize resize watching if sensor is availablei
        if (ResizeSensor) {
            this.resizeSensor = new ResizeSensor(this.element.nativeElement, () => this.onResized());
        }
    }
    ngOnDestroy() {
        if (this.resizeSensor) {
            this.resizeSensor.detach();
        }
    }
    onResized() {
        const newWidth = this.element.nativeElement.clientWidth;
        const newHeight = this.element.nativeElement.clientHeight;
        if (newWidth === this.oldWidth && newHeight === this.oldHeight) {
            return;
        }
        const event = new ResizedEvent(this.element, newWidth, newHeight, this.oldWidth, this.oldHeight);
        this.oldWidth = this.element.nativeElement.clientWidth;
        this.oldHeight = this.element.nativeElement.clientHeight;
        this.resized.emit(event);
    }
}
ResizedDirective.ɵfac = function ResizedDirective_Factory(t) { return new (t || ResizedDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef)); };
ResizedDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ResizedDirective, selectors: [["", "resized", ""]], outputs: { resized: "resized" } });
ResizedDirective.ctorParameters = () => [
    { type: ElementRef }
];
ResizedDirective.propDecorators = {
    resized: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizedDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[resized]'
            }]
    }], function () { return [{ type: ElementRef }]; }, { resized: [{
            type: Output
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplZC5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItcmVzaXplLWV2ZW50L3NyYy9saWIvcmVzaXplZC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFVLE1BQU0sRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUMvRixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDbkQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDOztBQU0vQyxNQUFNLE9BQU8sZ0JBQWdCO0FBQUcsSUFVOUIsWUFBNkIsT0FBbUI7QUFDbEQsUUFEK0IsWUFBTyxHQUFQLE9BQU8sQ0FBWTtBQUFDLFFBUHhDLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBZ0IsQ0FBQztBQUN0RCxJQU9FLENBQUM7QUFDSCxJQUNFLFFBQVE7QUFBSyxRQUNYLDBEQUEwRDtBQUM5RCxRQUFJLElBQUksWUFBWSxFQUFFO0FBQ3RCLFlBQU0sSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztBQUMvRixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0gsSUFDRSxXQUFXO0FBQUssUUFDZCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7QUFDM0IsWUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2pDLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNVLFNBQVM7QUFBSyxRQUNwQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUM7QUFDNUQsUUFBSSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUM7QUFDOUQsUUFDSSxJQUFJLFFBQVEsS0FBSyxJQUFJLENBQUMsUUFBUSxJQUFJLFNBQVMsS0FBSyxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ3BFLFlBQU0sT0FBTztBQUNiLFNBQUs7QUFDTCxRQUNJLE1BQU0sS0FBSyxHQUFHLElBQUksWUFBWSxDQUM1QixJQUFJLENBQUMsT0FBTyxFQUNaLFFBQVEsRUFDUixTQUFTLEVBQ1QsSUFBSSxDQUFDLFFBQVEsRUFDYixJQUFJLENBQUMsU0FBUyxDQUNmLENBQUM7QUFDTixRQUNJLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDO0FBQzNELFFBQUksSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUM7QUFDN0QsUUFDSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM3QixJQUFFLENBQUM7QUFDSDs0Q0FuREMsU0FBUyxTQUFDLGtCQUNULDhDQUE4QztHQUM5QyxRQUFRLEVBQUUsV0FBVyxjQUN0QiwwR0FDSTtBQUFDO0FBQTBDLFlBUjVCLFVBQVU7QUFBRztBQUFHO0FBQW9DLHNCQVVyRSxNQUFNO0FBQ1I7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uSW5pdCwgT3V0cHV0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJlc2l6ZVNlbnNvciB9IGZyb20gJ2Nzcy1lbGVtZW50LXF1ZXJpZXMnO1xuaW1wb3J0IHsgUmVzaXplZEV2ZW50IH0gZnJvbSAnLi9yZXNpemVkLWV2ZW50JztcblxuQERpcmVjdGl2ZSh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdbcmVzaXplZF0nXG59KVxuZXhwb3J0IGNsYXNzIFJlc2l6ZWREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgQE91dHB1dCgpXG4gIHJlYWRvbmx5IHJlc2l6ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFJlc2l6ZWRFdmVudD4oKTtcblxuICBwcml2YXRlIG9sZFdpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgb2xkSGVpZ2h0OiBudW1iZXI7XG5cbiAgcHJpdmF0ZSByZXNpemVTZW5zb3I6IFJlc2l6ZVNlbnNvcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGVsZW1lbnQ6IEVsZW1lbnRSZWYpIHtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIC8vIG9ubHkgaW5pdGlhbGl6ZSByZXNpemUgd2F0Y2hpbmcgaWYgc2Vuc29yIGlzIGF2YWlsYWJsZWlcbiAgICBpZiAoUmVzaXplU2Vuc29yKSB7XG4gICAgICB0aGlzLnJlc2l6ZVNlbnNvciA9IG5ldyBSZXNpemVTZW5zb3IodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICgpID0+IHRoaXMub25SZXNpemVkKCkpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlc2l6ZVNlbnNvcikge1xuICAgICAgdGhpcy5yZXNpemVTZW5zb3IuZGV0YWNoKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvblJlc2l6ZWQoKTogdm9pZCB7XG4gICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cbiAgICBpZiAobmV3V2lkdGggPT09IHRoaXMub2xkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSB0aGlzLm9sZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IFJlc2l6ZWRFdmVudChcbiAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgIG5ld1dpZHRoLFxuICAgICAgbmV3SGVpZ2h0LFxuICAgICAgdGhpcy5vbGRXaWR0aCxcbiAgICAgIHRoaXMub2xkSGVpZ2h0XG4gICAgKTtcblxuICAgIHRoaXMub2xkV2lkdGggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB0aGlzLm9sZEhlaWdodCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodDtcblxuICAgIHRoaXMucmVzaXplZC5lbWl0KGV2ZW50KTtcbiAgfVxuXG59XG4iXX0=