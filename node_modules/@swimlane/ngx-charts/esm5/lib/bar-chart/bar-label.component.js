import { __decorate } from "tslib";
import { Component, Input, OnChanges, SimpleChanges, ChangeDetectionStrategy, ElementRef, Output, EventEmitter } from '@angular/core';
import { formatLabel } from '../common/label.helper';
import * as ɵngcc0 from '@angular/core';

var _c0 = ["ngx-charts-bar-label", ""];
var BarLabelComponent = /** @class */ (function () {
    function BarLabelComponent(element) {
        this.dimensionsChanged = new EventEmitter();
        this.horizontalPadding = 2;
        this.verticalPadding = 5;
        this.element = element.nativeElement;
    }
    BarLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BarLabelComponent.prototype.getSize = function () {
        var h = this.element.getBoundingClientRect().height;
        var w = this.element.getBoundingClientRect().width;
        return { height: h, width: w, negative: this.value < 0 };
    };
    BarLabelComponent.prototype.ngAfterViewInit = function () {
        this.dimensionsChanged.emit(this.getSize());
    };
    BarLabelComponent.prototype.update = function () {
        if (this.valueFormatting) {
            this.formatedValue = this.valueFormatting(this.value);
        }
        else {
            this.formatedValue = formatLabel(this.value);
        }
        if (this.orientation === 'horizontal') {
            this.x = this.barX + this.barWidth;
            // if the value is negative then it's on the left of the x0.
            // we need to put the data label in front of the bar
            if (this.value < 0) {
                this.x = this.x - this.horizontalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.x = this.x + this.horizontalPadding;
                this.textAnchor = 'start';
            }
            this.y = this.barY + this.barHeight / 2;
        }
        else {
            // orientation must be "vertical"
            this.x = this.barX + this.barWidth / 2;
            this.y = this.barY + this.barHeight;
            if (this.value < 0) {
                this.y = this.y + this.verticalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.y = this.y - this.verticalPadding;
                this.textAnchor = 'start';
            }
            this.transform = "rotate(-45, " + this.x + " , " + this.y + ")";
        }
    };
    BarLabelComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "value", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "barX", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "barY", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "barWidth", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "barHeight", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "orientation", void 0);
    __decorate([
        Output()
    ], BarLabelComponent.prototype, "dimensionsChanged", void 0);
BarLabelComponent.ɵfac = function BarLabelComponent_Factory(t) { return new (t || BarLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef)); };
BarLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarLabelComponent, selectors: [["g", "ngx-charts-bar-label", ""]], inputs: { value: "value", valueFormatting: "valueFormatting", barX: "barX", barY: "barY", barWidth: "barWidth", barHeight: "barHeight", orientation: "orientation" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 2, vars: 5, consts: [["alignment-baseline", "middle", 1, "textDataLabel"]], template: function BarLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("text-anchor", ctx.textAnchor)("transform", ctx.transform)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.formatedValue, " ");
    } }, styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"], changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bar-label]',
                template: "\n    <svg:text\n      class=\"textDataLabel\"\n      alignment-baseline=\"middle\"\n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n    >\n      {{ formatedValue }}\n    </svg:text>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".textDataLabel{font-size:11px}"]
            }]
    }], function () { return [{ type: ElementRef }]; }, { dimensionsChanged: [{
            type: Output
        }], value: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], barX: [{
            type: Input
        }], barY: [{
            type: Input
        }], barWidth: [{
            type: Input
        }], barHeight: [{
            type: Input
        }], orientation: [{
            type: Input
        }] }); })();
    return BarLabelComponent;
}());
export { BarLabelComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFyLWxhYmVsLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiQHN3aW1sYW5lL25neC1jaGFydHMvbGliL2Jhci1jaGFydC9iYXItbGFiZWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxTQUFTLEVBQ1QsYUFBYSxFQUNiLHVCQUF1QixFQUN2QixVQUFVLEVBQ1YsTUFBTSxFQUNOLFlBQVksRUFDYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7Ozs7QUFtQnJEO0FBQXFELElBb0JuRCwyQkFBWSxPQUFtQjtBQUNqQyxRQVpZLHNCQUFpQixHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO0FBQ3RFLFFBSUUsc0JBQWlCLEdBQVcsQ0FBQyxDQUFDO0FBQ2hDLFFBQUUsb0JBQWUsR0FBVyxDQUFDLENBQUM7QUFDOUIsUUFLSSxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFDekMsSUFBRSxDQUFDO0FBQ0gsSUFDRSx1Q0FBVyxHQUFYLFVBQVksT0FBc0I7QUFBSSxRQUNwQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDbEIsSUFBRSxDQUFDO0FBRUgsSUFBRSxtQ0FBTyxHQUFQO0FBQWMsUUFDWixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLHFCQUFxQixFQUFFLENBQUMsTUFBTSxDQUFDO0FBQzFELFFBQUksSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEtBQUssQ0FBQztBQUN6RCxRQUFJLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLENBQUM7QUFDN0QsSUFBRSxDQUFDO0FBRUgsSUFBRSwyQ0FBZSxHQUFmO0FBQWMsUUFDWixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBQ2hELElBQUUsQ0FBQztBQUVILElBQUUsa0NBQU0sR0FBTjtBQUFjLFFBQ1osSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQzlCLFlBQU0sSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM1RCxTQUFLO0FBQUMsYUFBSztBQUNYLFlBQU0sSUFBSSxDQUFDLGFBQWEsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ25ELFNBQUs7QUFDTCxRQUNJLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxZQUFZLEVBQUU7QUFDM0MsWUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUN6QyxZQUFNLDREQUE0RDtBQUNsRSxZQUFNLG9EQUFvRDtBQUMxRCxZQUFNLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUU7QUFDMUIsZ0JBQVEsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztBQUNqRCxnQkFBUSxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztBQUNoQyxhQUFPO0FBQUMsaUJBQUs7QUFDYixnQkFBUSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO0FBQ2pELGdCQUFRLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDO0FBQ2xDLGFBQU87QUFDUCxZQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztBQUM5QyxTQUFLO0FBQUMsYUFBSztBQUNYLFlBQU0saUNBQWlDO0FBQ3ZDLFlBQU0sSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQzdDLFlBQU0sSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7QUFDMUMsWUFDTSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFO0FBQzFCLGdCQUFRLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO0FBQy9DLGdCQUFRLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO0FBQ2hDLGFBQU87QUFBQyxpQkFBSztBQUNiLGdCQUFRLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO0FBQy9DLGdCQUFRLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDO0FBQ2xDLGFBQU87QUFDUCxZQUFNLElBQUksQ0FBQyxTQUFTLEdBQUcsaUJBQWUsSUFBSSxDQUFDLENBQUMsV0FBTSxJQUFJLENBQUMsQ0FBQyxNQUFHLENBQUM7QUFDNUQsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNGO0FBQzRELGdCQXJEdEMsVUFBVTtBQUFHO0FBQzNCLElBcEJFO0FBQ0wsUUFESCxLQUFLLEVBQUU7QUFBQyxvREFBTTtBQUNoQixJQUFVO0FBQWEsUUFBckIsS0FBSyxFQUFFO0FBQUMsOERBQXFCO0FBQy9CLElBQVU7QUFDSixRQURKLEtBQUssRUFBRTtBQUFDLG1EQUFLO0FBQ2YsSUFBVTtBQUNKLFFBREosS0FBSyxFQUFFO0FBQUMsbURBQUs7QUFDZixJQUFVO0FBQ1IsUUFEQSxLQUFLLEVBQUU7QUFBQyx1REFBUztBQUNuQixJQUFVO0FBQ1QsUUFEQyxLQUFLLEVBQUU7QUFBQyx3REFBVTtBQUNwQixJQUFVO0FBQ1gsUUFERyxLQUFLLEVBQUU7QUFBQywwREFBWTtBQUV2QixJQUFZO0FBQWEsUUFBdEIsTUFBTSxFQUFFO0FBQUMsZ0VBQTBEO0lBVHpELGlCQUFpQix3QkFqQjdCLFNBQVMsQ0FBQyxjQUNULFFBQVEsRUFBRSx5QkFBeUIsY0FDbkMsUUFBUSxFQUFFO3dQQVdULGNBRUQsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU0sa0VBQ2hELENBQUMsUUFDVyxpQkFBaUIsQ0F3RTdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCx3QkFBQztBQUNBLENBREEsQUF4RUQsSUF3RUM7QUFDRCxTQXpFYSxpQkFBaUI7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIEVsZW1lbnRSZWYsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZm9ybWF0TGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwuaGVscGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWJhci1sYWJlbF0nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzdmc6dGV4dFxuICAgICAgY2xhc3M9XCJ0ZXh0RGF0YUxhYmVsXCJcbiAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cIm1pZGRsZVwiXG4gICAgICBbYXR0ci50ZXh0LWFuY2hvcl09XCJ0ZXh0QW5jaG9yXCJcbiAgICAgIFthdHRyLnRyYW5zZm9ybV09XCJ0cmFuc2Zvcm1cIlxuICAgICAgW2F0dHIueF09XCJ4XCJcbiAgICAgIFthdHRyLnldPVwieVwiXG4gICAgPlxuICAgICAge3sgZm9ybWF0ZWRWYWx1ZSB9fVxuICAgIDwvc3ZnOnRleHQ+XG4gIGAsXG4gIHN0eWxlVXJsczogWycuL2Jhci1sYWJlbC5jb21wb25lbnQuc2NzcyddLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBCYXJMYWJlbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIHZhbHVlO1xuICBASW5wdXQoKSB2YWx1ZUZvcm1hdHRpbmc6IGFueTtcbiAgQElucHV0KCkgYmFyWDtcbiAgQElucHV0KCkgYmFyWTtcbiAgQElucHV0KCkgYmFyV2lkdGg7XG4gIEBJbnB1dCgpIGJhckhlaWdodDtcbiAgQElucHV0KCkgb3JpZW50YXRpb247XG5cbiAgQE91dHB1dCgpIGRpbWVuc2lvbnNDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBlbGVtZW50OiBhbnk7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICBob3Jpem9udGFsUGFkZGluZzogbnVtYmVyID0gMjtcbiAgdmVydGljYWxQYWRkaW5nOiBudW1iZXIgPSA1O1xuICBmb3JtYXRlZFZhbHVlOiBzdHJpbmc7XG4gIHRyYW5zZm9ybTogc3RyaW5nO1xuICB0ZXh0QW5jaG9yOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZikge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0U2l6ZSgpOiBhbnkge1xuICAgIGNvbnN0IGggPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIGNvbnN0IHcgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgcmV0dXJuIHsgaGVpZ2h0OiBoLCB3aWR0aDogdywgbmVnYXRpdmU6IHRoaXMudmFsdWUgPCAwIH07XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHRoaXMuZ2V0U2l6ZSgpKTtcbiAgfVxuXG4gIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy52YWx1ZUZvcm1hdHRpbmcpIHtcbiAgICAgIHRoaXMuZm9ybWF0ZWRWYWx1ZSA9IHRoaXMudmFsdWVGb3JtYXR0aW5nKHRoaXMudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvcm1hdGVkVmFsdWUgPSBmb3JtYXRMYWJlbCh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICB0aGlzLnggPSB0aGlzLmJhclggKyB0aGlzLmJhcldpZHRoO1xuICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlIHRoZW4gaXQncyBvbiB0aGUgbGVmdCBvZiB0aGUgeDAuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHB1dCB0aGUgZGF0YSBsYWJlbCBpbiBmcm9udCBvZiB0aGUgYmFyXG4gICAgICBpZiAodGhpcy52YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy54ID0gdGhpcy54IC0gdGhpcy5ob3Jpem9udGFsUGFkZGluZztcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggPSB0aGlzLnggKyB0aGlzLmhvcml6b250YWxQYWRkaW5nO1xuICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgfVxuICAgICAgdGhpcy55ID0gdGhpcy5iYXJZICsgdGhpcy5iYXJIZWlnaHQgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvcmllbnRhdGlvbiBtdXN0IGJlIFwidmVydGljYWxcIlxuICAgICAgdGhpcy54ID0gdGhpcy5iYXJYICsgdGhpcy5iYXJXaWR0aCAvIDI7XG4gICAgICB0aGlzLnkgPSB0aGlzLmJhclkgKyB0aGlzLmJhckhlaWdodDtcblxuICAgICAgaWYgKHRoaXMudmFsdWUgPCAwKSB7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueSArIHRoaXMudmVydGljYWxQYWRkaW5nO1xuICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnZW5kJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueSAtIHRoaXMudmVydGljYWxQYWRkaW5nO1xuICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm0gPSBgcm90YXRlKC00NSwgJHt0aGlzLnh9ICwgJHt0aGlzLnl9KWA7XG4gICAgfVxuICB9XG59XG4iXX0=