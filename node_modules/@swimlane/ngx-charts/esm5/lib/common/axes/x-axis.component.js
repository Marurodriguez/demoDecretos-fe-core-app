import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ViewChild, ChangeDetectionStrategy } from '@angular/core';
import { XAxisTicksComponent } from './x-axis-ticks.component';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './x-axis-ticks.component';
import * as ɵngcc3 from './axis-label.component';

var _c0 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function XAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("rotateTicks", ctx_r0.rotateTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.xScale)("orient", ctx_r0.xOrient)("showGridLines", ctx_r0.showGridLines)("gridLineHeight", ctx_r0.dims.height)("width", ctx_r0.dims.width)("tickValues", ctx_r0.ticks);
} }
function XAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", "bottom")("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var XAxisComponent = /** @class */ (function () {
    function XAxisComponent() {
        this.rotateTicks = true;
        this.showGridLines = false;
        this.xOrient = 'bottom';
        this.xAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.xAxisClassName = 'x axis';
        this.labelOffset = 0;
        this.fill = 'none';
        this.stroke = 'stroke';
        this.tickStroke = '#ccc';
        this.strokeWidth = 'none';
        this.padding = 5;
    }
    XAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisComponent.prototype.update = function () {
        this.transform = "translate(0," + (this.xAxisOffset + this.padding + this.dims.height) + ")";
        if (typeof this.xAxisTickCount !== 'undefined') {
            this.tickArguments = [this.xAxisTickCount];
        }
    };
    XAxisComponent.prototype.emitTicksHeight = function (_a) {
        var _this = this;
        var height = _a.height;
        var newLabelOffset = height + 25 + 5;
        if (newLabelOffset !== this.labelOffset) {
            this.labelOffset = newLabelOffset;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ height: height });
            }, 0);
        }
    };
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xScale", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "dims", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "showLabel", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "labelText", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "ticks", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xAxisTickInterval", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xAxisTickCount", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xOrient", void 0);
    __decorate([
        Input()
    ], XAxisComponent.prototype, "xAxisOffset", void 0);
    __decorate([
        Output()
    ], XAxisComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild(XAxisTicksComponent)
    ], XAxisComponent.prototype, "ticksComponent", void 0);
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(); };
XAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisComponent, selectors: [["g", "ngx-charts-x-axis", ""]], viewQuery: function XAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(XAxisTicksComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { rotateTicks: "rotateTicks", showGridLines: "showGridLines", xOrient: "xOrient", xAxisOffset: "xAxisOffset", xScale: "xScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", showLabel: "showLabel", labelText: "labelText", ticks: "ticks", xAxisTickInterval: "xAxisTickInterval", xAxisTickCount: "xAxisTickCount" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 3, vars: 4, consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function XAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, XAxisComponent__svg_g_1_Template, 1, 12, "g", 0);
        ɵngcc0.ɵɵtemplate(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.xAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.XAxisTicksComponent, ɵngcc3.AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis]',
                template: "\n    <svg:g [attr.class]=\"xAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-x-axis-ticks\n        *ngIf=\"xScale\"\n        [trimTicks]=\"trimTicks\"\n        [rotateTicks]=\"rotateTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"xScale\"\n        [orient]=\"xOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineHeight]=\"dims.height\"\n        [width]=\"dims.width\"\n        [tickValues]=\"ticks\"\n        (dimensionsChanged)=\"emitTicksHeight($event)\"\n      />\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"'bottom'\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { rotateTicks: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], xOrient: [{
            type: Input
        }], xAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], xScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], ticks: [{
            type: Input
        }], xAxisTickInterval: [{
            type: Input
        }], xAxisTickCount: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [XAxisTicksComponent]
        }] }); })();
    return XAxisComponent;
}());
export { XAxisComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieC1heGlzLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiQHN3aW1sYW5lL25neC1jaGFydHMvbGliL2NvbW1vbi9heGVzL3gtYXhpcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUVMLE1BQU0sRUFDTixZQUFZLEVBRVosU0FBUyxFQUNULHVCQUF1QixFQUN4QixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0MvRDtBQUFrRCxJQUFsRDtBQUE0QixRQUlqQixnQkFBVyxHQUFZLElBQUksQ0FBQztBQUN2QyxRQUVXLGtCQUFhLEdBQUcsS0FBSyxDQUFDO0FBQ2pDLFFBS1csWUFBTyxHQUFXLFFBQVEsQ0FBQztBQUN0QyxRQUFXLGdCQUFXLEdBQVcsQ0FBQyxDQUFDO0FBQ25DLFFBQ1ksc0JBQWlCLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUNuRCxRQUNFLG1CQUFjLEdBQVcsUUFBUSxDQUFDO0FBQ3BDLFFBR0UsZ0JBQVcsR0FBVyxDQUFDLENBQUM7QUFDMUIsUUFBRSxTQUFJLEdBQVcsTUFBTSxDQUFDO0FBQ3hCLFFBQUUsV0FBTSxHQUFXLFFBQVEsQ0FBQztBQUM1QixRQUFFLGVBQVUsR0FBVyxNQUFNLENBQUM7QUFDOUIsUUFBRSxnQkFBVyxHQUFXLE1BQU0sQ0FBQztBQUMvQixRQUFFLFlBQU8sR0FBVyxDQUFDLENBQUM7QUFDdEIsSUF3QkEsQ0FBQztBQUNELElBdEJFLG9DQUFXLEdBQVgsVUFBWSxPQUFzQjtBQUFJLFFBQ3BDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUNsQixJQUFFLENBQUM7QUFFSCxJQUFFLCtCQUFNLEdBQU47QUFBYyxRQUNaLElBQUksQ0FBQyxTQUFTLEdBQUcsa0JBQWUsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxPQUFHLENBQUM7QUFDMUYsUUFDSSxJQUFJLE9BQU8sSUFBSSxDQUFDLGNBQWMsS0FBSyxXQUFXLEVBQUU7QUFDcEQsWUFBTSxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ2pELFNBQUs7QUFDTCxJQUFFLENBQUM7QUFFSCxJQUFFLHdDQUFlLEdBQWYsVUFBZ0IsRUFBVTtBQUFJLFFBQTlCLGlCQVFDO0FBQ0gsWUFUb0Isa0JBQU07QUFBRSxRQUN4QixJQUFNLGNBQWMsR0FBRyxNQUFNLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMzQyxRQUFJLElBQUksY0FBYyxLQUFLLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDN0MsWUFBTSxJQUFJLENBQUMsV0FBVyxHQUFHLGNBQWMsQ0FBQztBQUN4QyxZQUFNLFVBQVUsQ0FBQztBQUNYLGdCQUFFLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLFFBQUEsRUFBRSxDQUFDLENBQUM7QUFDaEQsWUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDWixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0YsSUFuRFU7QUFDTixRQURGLEtBQUssRUFBRTtBQUFDLGtEQUFPO0FBQ2pCLElBQVU7QUFDSixRQURKLEtBQUssRUFBRTtBQUFDLGdEQUFLO0FBQ2YsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLHFEQUFtQjtBQUM3QixJQUFVO0FBQWEsUUFBckIsS0FBSyxFQUFFO0FBQUMsdURBQTRCO0FBQ3RDLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyx5REFBc0I7QUFDaEMsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLDBEQUFlO0FBQ3pCLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyx5REFBc0I7QUFDaEMsSUFBVTtBQUNULFFBREMsS0FBSyxFQUFFO0FBQUMscURBQVU7QUFDcEIsSUFBVTtBQUNULFFBREMsS0FBSyxFQUFFO0FBQUMscURBQVU7QUFDcEIsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLGlEQUFhO0FBQ3ZCLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyw2REFBa0I7QUFDNUIsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLDBEQUFvQjtBQUM5QixJQUFVO0FBQWEsUUFBckIsS0FBSyxFQUFFO0FBQUMsbURBQTJCO0FBQ3JDLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyx1REFBd0I7QUFFbkMsSUFBWTtBQUFhLFFBQXRCLE1BQU0sRUFBRTtBQUFDLDZEQUF1QztBQUVuRCxJQVdrQztBQUFhLFFBQTVDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQztBQUFDLDBEQUFvQztJQTdCekQsY0FBYyx3QkFsQzFCLFNBQVMsQ0FBQyxjQUNULFFBQVEsRUFBRTtBQUFzQixjQUNoQyxRQUFRLEVBQUU7Ozs7O29sQkE2QlQsY0FDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTSxVQUNoRCxDQUFDLFFBQ1csY0FBYyxDQW9EMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCxxQkFBQztBQUNBLENBREEsQUFwREQsSUFvREM7QUFDRCxTQXJEYSxjQUFjO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgT25DaGFuZ2VzLFxuICBWaWV3Q2hpbGQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBYQXhpc1RpY2tzQ29tcG9uZW50IH0gZnJvbSAnLi94LWF4aXMtdGlja3MuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXgtYXhpc10nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzdmc6ZyBbYXR0ci5jbGFzc109XCJ4QXhpc0NsYXNzTmFtZVwiIFthdHRyLnRyYW5zZm9ybV09XCJ0cmFuc2Zvcm1cIj5cbiAgICAgIDxzdmc6Z1xuICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpcy10aWNrc1xuICAgICAgICAqbmdJZj1cInhTY2FsZVwiXG4gICAgICAgIFt0cmltVGlja3NdPVwidHJpbVRpY2tzXCJcbiAgICAgICAgW3JvdGF0ZVRpY2tzXT1cInJvdGF0ZVRpY2tzXCJcbiAgICAgICAgW21heFRpY2tMZW5ndGhdPVwibWF4VGlja0xlbmd0aFwiXG4gICAgICAgIFt0aWNrRm9ybWF0dGluZ109XCJ0aWNrRm9ybWF0dGluZ1wiXG4gICAgICAgIFt0aWNrQXJndW1lbnRzXT1cInRpY2tBcmd1bWVudHNcIlxuICAgICAgICBbdGlja1N0cm9rZV09XCJ0aWNrU3Ryb2tlXCJcbiAgICAgICAgW3NjYWxlXT1cInhTY2FsZVwiXG4gICAgICAgIFtvcmllbnRdPVwieE9yaWVudFwiXG4gICAgICAgIFtzaG93R3JpZExpbmVzXT1cInNob3dHcmlkTGluZXNcIlxuICAgICAgICBbZ3JpZExpbmVIZWlnaHRdPVwiZGltcy5oZWlnaHRcIlxuICAgICAgICBbd2lkdGhdPVwiZGltcy53aWR0aFwiXG4gICAgICAgIFt0aWNrVmFsdWVzXT1cInRpY2tzXCJcbiAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cImVtaXRUaWNrc0hlaWdodCgkZXZlbnQpXCJcbiAgICAgIC8+XG4gICAgICA8c3ZnOmdcbiAgICAgICAgbmd4LWNoYXJ0cy1heGlzLWxhYmVsXG4gICAgICAgICpuZ0lmPVwic2hvd0xhYmVsXCJcbiAgICAgICAgW2xhYmVsXT1cImxhYmVsVGV4dFwiXG4gICAgICAgIFtvZmZzZXRdPVwibGFiZWxPZmZzZXRcIlxuICAgICAgICBbb3JpZW50XT1cIidib3R0b20nXCJcbiAgICAgICAgW2hlaWdodF09XCJkaW1zLmhlaWdodFwiXG4gICAgICAgIFt3aWR0aF09XCJkaW1zLndpZHRoXCJcbiAgICAgID48L3N2ZzpnPlxuICAgIDwvc3ZnOmc+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFhBeGlzQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgeFNjYWxlO1xuICBASW5wdXQoKSBkaW1zO1xuICBASW5wdXQoKSB0cmltVGlja3M6IGJvb2xlYW47XG4gIEBJbnB1dCgpIHJvdGF0ZVRpY2tzOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCkgbWF4VGlja0xlbmd0aDogbnVtYmVyO1xuICBASW5wdXQoKSB0aWNrRm9ybWF0dGluZztcbiAgQElucHV0KCkgc2hvd0dyaWRMaW5lcyA9IGZhbHNlO1xuICBASW5wdXQoKSBzaG93TGFiZWw7XG4gIEBJbnB1dCgpIGxhYmVsVGV4dDtcbiAgQElucHV0KCkgdGlja3M6IGFueVtdO1xuICBASW5wdXQoKSB4QXhpc1RpY2tJbnRlcnZhbDtcbiAgQElucHV0KCkgeEF4aXNUaWNrQ291bnQ6IGFueTtcbiAgQElucHV0KCkgeE9yaWVudDogc3RyaW5nID0gJ2JvdHRvbSc7XG4gIEBJbnB1dCgpIHhBeGlzT2Zmc2V0OiBudW1iZXIgPSAwO1xuXG4gIEBPdXRwdXQoKSBkaW1lbnNpb25zQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICB4QXhpc0NsYXNzTmFtZTogc3RyaW5nID0gJ3ggYXhpcyc7XG5cbiAgdGlja0FyZ3VtZW50czogYW55O1xuICB0cmFuc2Zvcm06IGFueTtcbiAgbGFiZWxPZmZzZXQ6IG51bWJlciA9IDA7XG4gIGZpbGw6IHN0cmluZyA9ICdub25lJztcbiAgc3Ryb2tlOiBzdHJpbmcgPSAnc3Ryb2tlJztcbiAgdGlja1N0cm9rZTogc3RyaW5nID0gJyNjY2MnO1xuICBzdHJva2VXaWR0aDogc3RyaW5nID0gJ25vbmUnO1xuICBwYWRkaW5nOiBudW1iZXIgPSA1O1xuXG4gIEBWaWV3Q2hpbGQoWEF4aXNUaWNrc0NvbXBvbmVudCkgdGlja3NDb21wb25lbnQ6IFhBeGlzVGlja3NDb21wb25lbnQ7XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB1cGRhdGUoKTogdm9pZCB7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKDAsJHt0aGlzLnhBeGlzT2Zmc2V0ICsgdGhpcy5wYWRkaW5nICsgdGhpcy5kaW1zLmhlaWdodH0pYDtcblxuICAgIGlmICh0eXBlb2YgdGhpcy54QXhpc1RpY2tDb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudGlja0FyZ3VtZW50cyA9IFt0aGlzLnhBeGlzVGlja0NvdW50XTtcbiAgICB9XG4gIH1cblxuICBlbWl0VGlja3NIZWlnaHQoeyBoZWlnaHQgfSk6IHZvaWQge1xuICAgIGNvbnN0IG5ld0xhYmVsT2Zmc2V0ID0gaGVpZ2h0ICsgMjUgKyA1O1xuICAgIGlmIChuZXdMYWJlbE9mZnNldCAhPT0gdGhpcy5sYWJlbE9mZnNldCkge1xuICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IG5ld0xhYmVsT2Zmc2V0O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc0NoYW5nZWQuZW1pdCh7IGhlaWdodCB9KTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxufVxuIl19