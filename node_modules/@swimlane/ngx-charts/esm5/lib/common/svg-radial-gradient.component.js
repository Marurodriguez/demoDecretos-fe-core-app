import { __decorate } from "tslib";
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

var _c0 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var SvgRadialGradientComponent = /** @class */ (function () {
    function SvgRadialGradientComponent() {
        this.endOpacity = 1;
        this.cx = 0;
        this.cy = 0;
    }
    Object.defineProperty(SvgRadialGradientComponent.prototype, "stops", {
        get: function () {
            return this.stopsInput || this.stopsDefault;
        },
        set: function (value) {
            this.stopsInput = value;
        },
        enumerable: true,
        configurable: true
    });
    SvgRadialGradientComponent.prototype.ngOnChanges = function (changes) {
        this.r = '30%';
        if ('color' in changes || 'startOpacity' in changes || 'endOpacity' in changes) {
            this.stopsDefault = [
                {
                    offset: 0,
                    color: this.color,
                    opacity: this.startOpacity
                },
                {
                    offset: 100,
                    color: this.color,
                    opacity: this.endOpacity
                }
            ];
        }
    };
    __decorate([
        Input()
    ], SvgRadialGradientComponent.prototype, "color", void 0);
    __decorate([
        Input()
    ], SvgRadialGradientComponent.prototype, "name", void 0);
    __decorate([
        Input()
    ], SvgRadialGradientComponent.prototype, "startOpacity", void 0);
    __decorate([
        Input()
    ], SvgRadialGradientComponent.prototype, "endOpacity", void 0);
    __decorate([
        Input()
    ], SvgRadialGradientComponent.prototype, "cx", void 0);
    __decorate([
        Input()
    ], SvgRadialGradientComponent.prototype, "cy", void 0);
    __decorate([
        Input()
    ], SvgRadialGradientComponent.prototype, "stops", null);
SvgRadialGradientComponent.ɵfac = function SvgRadialGradientComponent_Factory(t) { return new (t || SvgRadialGradientComponent)(); };
SvgRadialGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgRadialGradientComponent, selectors: [["g", "ngx-charts-svg-radial-gradient", ""]], inputs: { endOpacity: "endOpacity", cx: "cx", cy: "cy", stops: "stops", color: "color", name: "name", startOpacity: "startOpacity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 2, vars: 5, consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgRadialGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "radialGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SvgRadialGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-radial-gradient]',
                template: "\n    <svg:radialGradient [id]=\"name\" [attr.cx]=\"cx\" [attr.cy]=\"cy\" [attr.r]=\"r\" gradientUnits=\"userSpaceOnUse\">\n      <svg:stop\n        *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:radialGradient>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { endOpacity: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], stops: [{
            type: Input
        }], color: [{
            type: Input
        }], name: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }] }); })();
    return SvgRadialGradientComponent;
}());
export { SvgRadialGradientComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLXJhZGlhbC1ncmFkaWVudC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIkBzd2ltbGFuZS9uZ3gtY2hhcnRzL2xpYi9jb21tb24vc3ZnLXJhZGlhbC1ncmFkaWVudC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFhLHVCQUF1QixFQUFpQixNQUFNLGVBQWUsQ0FBQzs7Ozs7Ozs7Ozs7OztBQWdCcEc7QUFBOEQsSUFBOUQ7QUFBd0MsUUFJN0IsZUFBVSxHQUFHLENBQUMsQ0FBQztBQUMxQixRQUFXLE9BQUUsR0FBVyxDQUFDLENBQUM7QUFDMUIsUUFBVyxPQUFFLEdBQVcsQ0FBQyxDQUFDO0FBQzFCLElBZ0NBLENBQUM7QUFDRCxJQS9CRSxzQkFBSSw2Q0FBSztBQUFJLGFBQWI7QUFBYyxZQUNaLE9BQU8sSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDO0FBQ2hELFFBQUUsQ0FBQztBQUVILGFBQUUsVUFBVSxLQUFZO0FBQ3hCLFlBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7QUFDNUIsUUFBRSxDQUFDO0FBRUg7QUFFWTtBQUNGLE9BVFA7QUFDSCxJQVVFLGdEQUFXLEdBQVgsVUFBWSxPQUFzQjtBQUFJLFFBQ3BDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQ25CLFFBQUksSUFBSSxPQUFPLElBQUksT0FBTyxJQUFJLGNBQWMsSUFBSSxPQUFPLElBQUksWUFBWSxJQUFJLE9BQU8sRUFBRTtBQUNwRixZQUFNLElBQUksQ0FBQyxZQUFZLEdBQUc7QUFDMUIsZ0JBQVE7QUFDUixvQkFBVSxNQUFNLEVBQUUsQ0FBQztBQUNuQixvQkFBVSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7QUFDM0Isb0JBQVUsT0FBTyxFQUFFLElBQUksQ0FBQyxZQUFZO0FBQ3BDLGlCQUFTO0FBQ1QsZ0JBQVE7QUFDUixvQkFBVSxNQUFNLEVBQUUsR0FBRztBQUNyQixvQkFBVSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7QUFDM0Isb0JBQVUsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVO0FBQ2xDLGlCQUFTO0FBQ1QsYUFBTyxDQUFDO0FBQ1IsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNGLElBdENVO0FBQWEsUUFBckIsS0FBSyxFQUFFO0FBQUMsNkRBQWM7QUFDeEIsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLDREQUFhO0FBQ3ZCLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyxvRUFBcUI7QUFDL0IsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLGtFQUFlO0FBQ3pCLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQywwREFBZTtBQUN6QixJQUFVO0FBQWEsUUFBckIsS0FBSyxFQUFFO0FBQUMsMERBQWU7QUFFMUIsSUFDRTtBQUFhLFFBRFosS0FBSyxFQUFFO0FBQ1YsMkRBRUc7SUFYVSwwQkFBMEIsd0JBZHRDLFNBQVMsQ0FBQyxjQUNULFFBQVEsRUFBRSxtQ0FBbUM7R0FDN0MsUUFBUSxFQUFFLG1XQVNULGNBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU0sVUFDaEQsQ0FBQyxRQUNXLDBCQUEwQixDQXVDdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCxpQ0FBQztBQUNBLENBREEsQUF2Q0QsSUF1Q0M7QUFDRCxTQXhDYSwwQkFBMEI7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXN2Zy1yYWRpYWwtZ3JhZGllbnRdJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnOnJhZGlhbEdyYWRpZW50IFtpZF09XCJuYW1lXCIgW2F0dHIuY3hdPVwiY3hcIiBbYXR0ci5jeV09XCJjeVwiIFthdHRyLnJdPVwiclwiIGdyYWRpZW50VW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiPlxuICAgICAgPHN2ZzpzdG9wXG4gICAgICAgICpuZ0Zvcj1cImxldCBzdG9wIG9mIHN0b3BzXCJcbiAgICAgICAgW2F0dHIub2Zmc2V0XT1cInN0b3Aub2Zmc2V0ICsgJyUnXCJcbiAgICAgICAgW3N0eWxlLnN0b3AtY29sb3JdPVwic3RvcC5jb2xvclwiXG4gICAgICAgIFtzdHlsZS5zdG9wLW9wYWNpdHldPVwic3RvcC5vcGFjaXR5XCJcbiAgICAgIC8+XG4gICAgPC9zdmc6cmFkaWFsR3JhZGllbnQ+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgY29sb3I6IHN0cmluZztcbiAgQElucHV0KCkgbmFtZTogc3RyaW5nO1xuICBASW5wdXQoKSBzdGFydE9wYWNpdHk6IG51bWJlcjtcbiAgQElucHV0KCkgZW5kT3BhY2l0eSA9IDE7XG4gIEBJbnB1dCgpIGN4OiBudW1iZXIgPSAwO1xuICBASW5wdXQoKSBjeTogbnVtYmVyID0gMDtcblxuICBASW5wdXQoKVxuICBnZXQgc3RvcHMoKTogYW55W10ge1xuICAgIHJldHVybiB0aGlzLnN0b3BzSW5wdXQgfHwgdGhpcy5zdG9wc0RlZmF1bHQ7XG4gIH1cblxuICBzZXQgc3RvcHModmFsdWU6IGFueVtdKSB7XG4gICAgdGhpcy5zdG9wc0lucHV0ID0gdmFsdWU7XG4gIH1cblxuICByOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzdG9wc0lucHV0OiBhbnlbXTtcbiAgcHJpdmF0ZSBzdG9wc0RlZmF1bHQ6IGFueVtdO1xuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICB0aGlzLnIgPSAnMzAlJztcbiAgICBpZiAoJ2NvbG9yJyBpbiBjaGFuZ2VzIHx8ICdzdGFydE9wYWNpdHknIGluIGNoYW5nZXMgfHwgJ2VuZE9wYWNpdHknIGluIGNoYW5nZXMpIHtcbiAgICAgIHRoaXMuc3RvcHNEZWZhdWx0ID0gW1xuICAgICAgICB7XG4gICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgIG9wYWNpdHk6IHRoaXMuc3RhcnRPcGFjaXR5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvZmZzZXQ6IDEwMCxcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmVuZE9wYWNpdHlcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==