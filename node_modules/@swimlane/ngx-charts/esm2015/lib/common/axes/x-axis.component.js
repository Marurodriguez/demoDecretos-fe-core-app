import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ViewChild, ChangeDetectionStrategy } from '@angular/core';
import { XAxisTicksComponent } from './x-axis-ticks.component';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './x-axis-ticks.component';
import * as ɵngcc3 from './axis-label.component';

const _c0 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function XAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("rotateTicks", ctx_r0.rotateTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.xScale)("orient", ctx_r0.xOrient)("showGridLines", ctx_r0.showGridLines)("gridLineHeight", ctx_r0.dims.height)("width", ctx_r0.dims.width)("tickValues", ctx_r0.ticks);
} }
function XAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", "bottom")("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
let XAxisComponent = class XAxisComponent {
    constructor() {
        this.rotateTicks = true;
        this.showGridLines = false;
        this.xOrient = 'bottom';
        this.xAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.xAxisClassName = 'x axis';
        this.labelOffset = 0;
        this.fill = 'none';
        this.stroke = 'stroke';
        this.tickStroke = '#ccc';
        this.strokeWidth = 'none';
        this.padding = 5;
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        this.transform = `translate(0,${this.xAxisOffset + this.padding + this.dims.height})`;
        if (typeof this.xAxisTickCount !== 'undefined') {
            this.tickArguments = [this.xAxisTickCount];
        }
    }
    emitTicksHeight({ height }) {
        const newLabelOffset = height + 25 + 5;
        if (newLabelOffset !== this.labelOffset) {
            this.labelOffset = newLabelOffset;
            setTimeout(() => {
                this.dimensionsChanged.emit({ height });
            }, 0);
        }
    }
};
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(); };
XAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisComponent, selectors: [["g", "ngx-charts-x-axis", ""]], viewQuery: function XAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(XAxisTicksComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { rotateTicks: "rotateTicks", showGridLines: "showGridLines", xOrient: "xOrient", xAxisOffset: "xAxisOffset", xScale: "xScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", showLabel: "showLabel", labelText: "labelText", ticks: "ticks", xAxisTickInterval: "xAxisTickInterval", xAxisTickCount: "xAxisTickCount" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 3, vars: 4, consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function XAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, XAxisComponent__svg_g_1_Template, 1, 12, "g", 0);
        ɵngcc0.ɵɵtemplate(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.xAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.XAxisTicksComponent, ɵngcc3.AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], XAxisComponent.prototype, "xScale", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "dims", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "trimTicks", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "rotateTicks", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "maxTickLength", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "tickFormatting", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "showGridLines", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "showLabel", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "labelText", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "ticks", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "xAxisTickInterval", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "xAxisTickCount", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "xOrient", void 0);
__decorate([
    Input()
], XAxisComponent.prototype, "xAxisOffset", void 0);
__decorate([
    Output()
], XAxisComponent.prototype, "dimensionsChanged", void 0);
__decorate([
    ViewChild(XAxisTicksComponent)
], XAxisComponent.prototype, "ticksComponent", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis]',
                template: `
    <svg:g [attr.class]="xAxisClassName" [attr.transform]="transform">
      <svg:g
        ngx-charts-x-axis-ticks
        *ngIf="xScale"
        [trimTicks]="trimTicks"
        [rotateTicks]="rotateTicks"
        [maxTickLength]="maxTickLength"
        [tickFormatting]="tickFormatting"
        [tickArguments]="tickArguments"
        [tickStroke]="tickStroke"
        [scale]="xScale"
        [orient]="xOrient"
        [showGridLines]="showGridLines"
        [gridLineHeight]="dims.height"
        [width]="dims.width"
        [tickValues]="ticks"
        (dimensionsChanged)="emitTicksHeight($event)"
      />
      <svg:g
        ngx-charts-axis-label
        *ngIf="showLabel"
        [label]="labelText"
        [offset]="labelOffset"
        [orient]="'bottom'"
        [height]="dims.height"
        [width]="dims.width"
      ></svg:g>
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { rotateTicks: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], xOrient: [{
            type: Input
        }], xAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], xScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], ticks: [{
            type: Input
        }], xAxisTickInterval: [{
            type: Input
        }], xAxisTickCount: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [XAxisTicksComponent]
        }] }); })();
export { XAxisComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieC1heGlzLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiQHN3aW1sYW5lL25neC1jaGFydHMvbGliL2NvbW1vbi9heGVzL3gtYXhpcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUVMLE1BQU0sRUFDTixZQUFZLEVBRVosU0FBUyxFQUNULHVCQUF1QixFQUN4QixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0MvRCxJQUFhLGNBQWMsR0FBM0IsTUFBYSxjQUFjO0FBQUcsSUFBOUI7QUFBZ0IsUUFJTCxnQkFBVyxHQUFZLElBQUksQ0FBQztBQUN2QyxRQUVXLGtCQUFhLEdBQUcsS0FBSyxDQUFDO0FBQ2pDLFFBS1csWUFBTyxHQUFXLFFBQVEsQ0FBQztBQUN0QyxRQUFXLGdCQUFXLEdBQVcsQ0FBQyxDQUFDO0FBQ25DLFFBQ1ksc0JBQWlCLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUNuRCxRQUNFLG1CQUFjLEdBQVcsUUFBUSxDQUFDO0FBQ3BDLFFBR0UsZ0JBQVcsR0FBVyxDQUFDLENBQUM7QUFDMUIsUUFBRSxTQUFJLEdBQVcsTUFBTSxDQUFDO0FBQ3hCLFFBQUUsV0FBTSxHQUFXLFFBQVEsQ0FBQztBQUM1QixRQUFFLGVBQVUsR0FBVyxNQUFNLENBQUM7QUFDOUIsUUFBRSxnQkFBVyxHQUFXLE1BQU0sQ0FBQztBQUMvQixRQUFFLFlBQU8sR0FBVyxDQUFDLENBQUM7QUFDdEIsSUF3QkEsQ0FBQztBQUNELElBdEJFLFdBQVcsQ0FBQyxPQUFzQjtBQUFJLFFBQ3BDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUNsQixJQUFFLENBQUM7QUFDSCxJQUNFLE1BQU07QUFBSyxRQUNULElBQUksQ0FBQyxTQUFTLEdBQUcsZUFBZSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQztBQUMxRixRQUNJLElBQUksT0FBTyxJQUFJLENBQUMsY0FBYyxLQUFLLFdBQVcsRUFBRTtBQUNwRCxZQUFNLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDakQsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILElBQ0UsZUFBZSxDQUFDLEVBQUUsTUFBTSxFQUFFO0FBQUksUUFDNUIsTUFBTSxjQUFjLEdBQUcsTUFBTSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDM0MsUUFBSSxJQUFJLGNBQWMsS0FBSyxJQUFJLENBQUMsV0FBVyxFQUFFO0FBQzdDLFlBQU0sSUFBSSxDQUFDLFdBQVcsR0FBRyxjQUFjLENBQUM7QUFDeEMsWUFBTSxVQUFVLENBQUMsR0FBRyxFQUFFO0FBQ3RCLGdCQUFRLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQ2hELFlBQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ1osU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUlBQUE7QUFuRFU7QUFDTixJQURGLEtBQUssRUFBRTtBQUFDLDhDQUFPO0FBQ1A7QUFDSixJQURKLEtBQUssRUFBRTtBQUFDLDRDQUFLO0FBQ0w7QUFBYSxJQUFyQixLQUFLLEVBQUU7QUFBQyxpREFBbUI7QUFDbkI7QUFBYSxJQUFyQixLQUFLLEVBQUU7QUFBQyxtREFBNEI7QUFDNUI7QUFBYSxJQUFyQixLQUFLLEVBQUU7QUFBQyxxREFBc0I7QUFDdEI7QUFBYSxJQUFyQixLQUFLLEVBQUU7QUFBQyxzREFBZTtBQUNmO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMscURBQXNCO0FBQ3RCO0FBQ1QsSUFEQyxLQUFLLEVBQUU7QUFBQyxpREFBVTtBQUNWO0FBQ1QsSUFEQyxLQUFLLEVBQUU7QUFBQyxpREFBVTtBQUNWO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsNkNBQWE7QUFDYjtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHlEQUFrQjtBQUNsQjtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHNEQUFvQjtBQUNwQjtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLCtDQUEyQjtBQUMzQjtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLG1EQUF3QjtBQUV2QjtBQUFhLElBQXRCLE1BQU0sRUFBRTtBQUFDLHlEQUF1QztBQWFqQjtBQUFhLElBQTVDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQztBQUFDLHNEQUFvQztBQTdCekQsY0FBYyxvQkFsQzFCLFNBQVMsQ0FBQyxVQUNULFFBQVEsRUFBRTthQUFzQixVQUNoQztNQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTZCVCxVQUNEO0NBQWUsRUFBRSx1QkFBdUIsQ0FBQztJQUFNLE1BQ2hELENBQUMsSUFDVzs7QUFBYyxDQW9EMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFDRDtBQUFDLFNBckRZLGNBQWM7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBPbkNoYW5nZXMsXG4gIFZpZXdDaGlsZCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFhBeGlzVGlja3NDb21wb25lbnQgfSBmcm9tICcuL3gtYXhpcy10aWNrcy5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteC1heGlzXScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpnIFthdHRyLmNsYXNzXT1cInhBeGlzQ2xhc3NOYW1lXCIgW2F0dHIudHJhbnNmb3JtXT1cInRyYW5zZm9ybVwiPlxuICAgICAgPHN2ZzpnXG4gICAgICAgIG5neC1jaGFydHMteC1heGlzLXRpY2tzXG4gICAgICAgICpuZ0lmPVwieFNjYWxlXCJcbiAgICAgICAgW3RyaW1UaWNrc109XCJ0cmltVGlja3NcIlxuICAgICAgICBbcm90YXRlVGlja3NdPVwicm90YXRlVGlja3NcIlxuICAgICAgICBbbWF4VGlja0xlbmd0aF09XCJtYXhUaWNrTGVuZ3RoXCJcbiAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cInRpY2tGb3JtYXR0aW5nXCJcbiAgICAgICAgW3RpY2tBcmd1bWVudHNdPVwidGlja0FyZ3VtZW50c1wiXG4gICAgICAgIFt0aWNrU3Ryb2tlXT1cInRpY2tTdHJva2VcIlxuICAgICAgICBbc2NhbGVdPVwieFNjYWxlXCJcbiAgICAgICAgW29yaWVudF09XCJ4T3JpZW50XCJcbiAgICAgICAgW3Nob3dHcmlkTGluZXNdPVwic2hvd0dyaWRMaW5lc1wiXG4gICAgICAgIFtncmlkTGluZUhlaWdodF09XCJkaW1zLmhlaWdodFwiXG4gICAgICAgIFt3aWR0aF09XCJkaW1zLndpZHRoXCJcbiAgICAgICAgW3RpY2tWYWx1ZXNdPVwidGlja3NcIlxuICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVwiZW1pdFRpY2tzSGVpZ2h0KCRldmVudClcIlxuICAgICAgLz5cbiAgICAgIDxzdmc6Z1xuICAgICAgICBuZ3gtY2hhcnRzLWF4aXMtbGFiZWxcbiAgICAgICAgKm5nSWY9XCJzaG93TGFiZWxcIlxuICAgICAgICBbbGFiZWxdPVwibGFiZWxUZXh0XCJcbiAgICAgICAgW29mZnNldF09XCJsYWJlbE9mZnNldFwiXG4gICAgICAgIFtvcmllbnRdPVwiJ2JvdHRvbSdcIlxuICAgICAgICBbaGVpZ2h0XT1cImRpbXMuaGVpZ2h0XCJcbiAgICAgICAgW3dpZHRoXT1cImRpbXMud2lkdGhcIlxuICAgICAgPjwvc3ZnOmc+XG4gICAgPC9zdmc6Zz5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgWEF4aXNDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSB4U2NhbGU7XG4gIEBJbnB1dCgpIGRpbXM7XG4gIEBJbnB1dCgpIHRyaW1UaWNrczogYm9vbGVhbjtcbiAgQElucHV0KCkgcm90YXRlVGlja3M6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBtYXhUaWNrTGVuZ3RoOiBudW1iZXI7XG4gIEBJbnB1dCgpIHRpY2tGb3JtYXR0aW5nO1xuICBASW5wdXQoKSBzaG93R3JpZExpbmVzID0gZmFsc2U7XG4gIEBJbnB1dCgpIHNob3dMYWJlbDtcbiAgQElucHV0KCkgbGFiZWxUZXh0O1xuICBASW5wdXQoKSB0aWNrczogYW55W107XG4gIEBJbnB1dCgpIHhBeGlzVGlja0ludGVydmFsO1xuICBASW5wdXQoKSB4QXhpc1RpY2tDb3VudDogYW55O1xuICBASW5wdXQoKSB4T3JpZW50OiBzdHJpbmcgPSAnYm90dG9tJztcbiAgQElucHV0KCkgeEF4aXNPZmZzZXQ6IG51bWJlciA9IDA7XG5cbiAgQE91dHB1dCgpIGRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHhBeGlzQ2xhc3NOYW1lOiBzdHJpbmcgPSAneCBheGlzJztcblxuICB0aWNrQXJndW1lbnRzOiBhbnk7XG4gIHRyYW5zZm9ybTogYW55O1xuICBsYWJlbE9mZnNldDogbnVtYmVyID0gMDtcbiAgZmlsbDogc3RyaW5nID0gJ25vbmUnO1xuICBzdHJva2U6IHN0cmluZyA9ICdzdHJva2UnO1xuICB0aWNrU3Ryb2tlOiBzdHJpbmcgPSAnI2NjYyc7XG4gIHN0cm9rZVdpZHRoOiBzdHJpbmcgPSAnbm9uZSc7XG4gIHBhZGRpbmc6IG51bWJlciA9IDU7XG5cbiAgQFZpZXdDaGlsZChYQXhpc1RpY2tzQ29tcG9uZW50KSB0aWNrc0NvbXBvbmVudDogWEF4aXNUaWNrc0NvbXBvbmVudDtcblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoMCwke3RoaXMueEF4aXNPZmZzZXQgKyB0aGlzLnBhZGRpbmcgKyB0aGlzLmRpbXMuaGVpZ2h0fSlgO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnhBeGlzVGlja0NvdW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy50aWNrQXJndW1lbnRzID0gW3RoaXMueEF4aXNUaWNrQ291bnRdO1xuICAgIH1cbiAgfVxuXG4gIGVtaXRUaWNrc0hlaWdodCh7IGhlaWdodCB9KTogdm9pZCB7XG4gICAgY29uc3QgbmV3TGFiZWxPZmZzZXQgPSBoZWlnaHQgKyAyNSArIDU7XG4gICAgaWYgKG5ld0xhYmVsT2Zmc2V0ICE9PSB0aGlzLmxhYmVsT2Zmc2V0KSB7XG4gICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gbmV3TGFiZWxPZmZzZXQ7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgaGVpZ2h0IH0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG59XG4iXX0=